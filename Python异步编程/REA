# 协程与任务
## 协程
通过async/await语法来声明协程是编写asyncio应用的推荐方式.例如,以下代码打印"hello",等待1秒,再打印"world":
```
import asyncio

async def main():
    print('hello')
    await asyncio.sleep(1)
    print('world')

asyncio.run(main())
```
**注意:** 简单的调用一个协程并不会使其被调度执行
```
main()
```
输出:
```
 RuntimeWarning: coroutine 'main' was never awaited
  main()
RuntimeWarning: Enable tracemalloc to get the object allocation traceback
```
要真正运行一个协程,asyncio提供了三种主要机制:
- asycnio.run()函数用来运行最高层级的入口点"main()"函数(参见上面的示例.)
- **等待**一个协程.以下代码会再等待3秒后打印'hello',然后再次等待1秒后打印'world'.

```
import asyncio
import time

async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    print(f"started at {time.strftime('%X')}")

    await say_after(3, 'hello')
    await say_after(1, 'world')

    print(f"finished at {time.strftime('%X')}")

asyncio.run(main())
```
输出:
```
started at 22:12:04
hello
world
finished at 22:12:08
```
从运行结果来看,先输出的'hello',过了1秒输出'world',而且总共用时4秒,所以并**没有**并发运行.
- asyncio.create_task()函数用来**并发**运行作为asyncio任务的多个协程任务.

```
import asyncio
import time

async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    task1 = asyncio.create_task(say_after(3, 'hello'))
    task2 = asyncio.create_task(say_after(1, 'world'))

    print(f"started at {time.strftime('%X')}")

    # 等两个任务都完成
    # 预期先输出world且用时少于4秒
    await task1
    await task2

    print(f"finished at {time.strftime('%X')}")

asyncio.run(main())
```
**注意**,先输出了world,并且时间比之前快了1秒:
```
started at 22:23:33
world
hello
finished at 22:23:36
```
所以想实现并发运行协程,得使用**task**.

## 可等待对象
如果一个对象可以在await语句中使用,那么它就是**可等待对象.许多asyncio API都被设计为接受可等待对象.

可等待对象有三种主要类型:**Coroutine**,**Task**和**Future**

**Coroutine(协程):**

Python协程属于可等待对象,因此可以在在他协程中被等待:
```
import asyncio

async def nested():
    return 42

async def main():
    # 直接调用协程函数什么都不会发生
    # 因为只是创建了协程对象,但协程对象并没有被等待
    print(nested())

    # 等待协程对象
    print(await nested())

asyncio.run(main())
```
输出:
```
RuntimeWarning: coroutine 'nested' was never awaited
  print(nested())
RuntimeWarning: Enable tracemalloc to get the object allocation traceback  
42
```
如果协程对象没有被等待,就会提示`coroutine 'nested' was never awaited`,并且不会被执行.

**重要:** 在文档中"协程"可用来表示两个紧密关联的概念:
- 协程函数:定义形式为async def 的函数
- 协程对象:调用*协程函数*返回的对象

asyncio也支持旧式基于*生成器*的协程(使用装饰器和yield from的)

**Task(任务)**

*任务*被用来**并行**调度协程

当一个协程通过asyncio.create_task()等函数封装为成*任务*,该协程会被自动调度执行:

```
import asyncio

async def nested():
    return 42

async def main():
    # Schedule nested() to run soon concurrently
    # with "main()".
    task = asyncio.create_task(nested())

    # "task" can now be used to cancel "nested()", or
    # can simply be awaited to wait until it is complete:
    await task

asyncio.run(main())
```

**Futures**

Future是一种特殊的**低层级**可等待对象,表示一个异步操作的**最终结果**.

当一个Future对象*被等待*,这意味着协程将保持等待直到该Future对象在其他地方操作完毕。

在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。

通常情况下**没有必要**在应用层级的代码中创建 Future 对象。

Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象:
```

async def main():
    await function_that_returns_a_future_object()

    # this is also valid:
    await asyncio.gather(
        function_that_returns_a_future_object(),
        some_python_coroutine()
    )
```

 一个很好的返回对象的低层级函数的示例是 loop.run_in_executor()。

**这段没看懂**

## 运行asyncio程序

asyncio.run(coro,*,debug=False)执行`coroutine coro`并返回结果.

此函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。

当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。

如果 debug 为 True，事件循环将以调试模式运行。

此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。

示例:
```
async def main():
    await asyncio.sleep(1)
    print('hello')

asyncio.run(main())
```

## 创建任务
`asyncio.create_task(coro,*,name=None)`

将coro协程封装为一个Task并调度其执行.返回Task对象.name不为None,它将使用Task.set_name()来设为任务的名称.该任务会在get_running_loop()返回的循环中执行,如果当前线程没有正在运行的循环则会引发RuntimeError.


```
background_tasks = set()

for i in range(10):
    task = asyncio.create_task(some_coro(param=i))

    # 建立一个强有力的联系
    background_tasks.add(task)

    # add_done_callback是回调函数,意思是当任务执行完之后,执行括号里的参数(回调函数)
    # 调用的方法是集合的discard方法,discard()的作用是删除集合里的元素
    # 所以,这段代码的意思是当任务执行完之后,伤处background_tasks里的元素
    # 作用是防止重复调用集合里的任务
    task.add_done_callback(background_tasks.discard)
```

## 休眠

coroutine `asyncio.sleep(delay,result=None)`

阻塞delay指定的秒数.

如果指定了result,则当协程完成时将其返回给调用者.

sleep()总是会挂起当前任务,以允许其他任务运行.

将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行。 这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环.

一下协程示例运行5秒,每秒显示一次当前日期:
```
import asyncio
import datetime

async def display_date():
    loop = asyncio.get_running_loop()
    end_time = loop.time() + 5.0
    while True:
        # 显示当前日期
        print(datetime.datetime.now())
        if (loop.time() + 1.0) >= end_time:
            break
        await asyncio.sleep(1)

asyncio.run(display_date())
```

## 并发运行任务

`awaitable` `asyncio.gather(*aws,return_exceptions=False)`

gather英文意思是收集

并发运行aws序列中的可等待对象.

如果aws中的某个可等待对象为协程,它将自动被作为一个任务调度.

如果所有可等待对象都成功完成,结果将是一个由所有返回值聚合而成的列表.结果值的顺序与aws中可等待对象的顺序一直.

如果return_exceptions为False(默认),所引发的首个异常会立即传播给等待gather()的任务.aws序列中的其他可等待对象**不会被取消**并将继续运行.

如果return_exceptions为True,异常会和成功的结果一样处理,并聚合至结果列表.

如果gather()被取消,所有被提交(尚未完成)的可等待对象也会被取消.

如果aws序列中的任一Task或Future对象被取消,它将被当作引发了CancelledError一样处理--在此情况下gather()调用**不会**被取消.这是为了防止一个已提交的Task/Future被取消导致其他Task/Future也被取消.

示例:
```
import asyncio

async def factorial(name, number):
    f = 1
    for i in range(2, number + 1):
        print(f"Task {name}: Compute factorial({number}), currently i={i}...")
        await asyncio.sleep(1)
        f *= i
    print(f"Task {name}: factorial({number}) = {f}")
    return f

async def main():
    # 同时执行三个协程,所有返回值会聚合成一个列表,赋值给L
    L = await asyncio.gather(
        factorial("A", 2),
        factorial("B", 3),
        factorial("C", 4),
    )
    print(L)

asyncio.run(main())

# Expected output:
#
#     Task A: Compute factorial(2), currently i=2...
#     Task B: Compute factorial(3), currently i=2...
#     Task C: Compute factorial(4), currently i=2...
#     Task A: factorial(2) = 2
#     Task B: Compute factorial(3), currently i=3...
#     Task C: Compute factorial(4), currently i=3...
#     Task B: factorial(3) = 6
#     Task C: Compute factorial(4), currently i=4...
#     Task C: factorial(4) = 24
#     [2, 6, 24]
```
